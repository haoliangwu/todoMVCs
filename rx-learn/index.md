## 创建 observable 总结

### 基本
* create 为最基本的方法
* of 创建有限的同步序列流
* from 创建任何可序列化的参数的序列流（比如 Array String 或者 Promise）

### 事件类型
* fromEvent 根据 DOM 元素的各种事件创建一个事件流
* fromEventPattern 根据类事件对象来创建一个事件流（所谓类事件就是存在注册和反注册方法的事件模型）

### 特殊类型
* empty 创建一个空队列流 什么都不做
* never 创建一个无穷队列流 未来会做某件事，但是你等不到
* throw 创建一个抛出错误的流

### 时间类型
* timer 创建一个自定义触发时间点，定时触发元素的队列流
* interval 创建一个定时触发元素的队列流

## operators
* map 从一个流变换为另一个流（体现一种 x -> y 映射关系）
* mapTo 同 map, 只不过从一个流变化为另一个固定的流
* filter 根据某些断言，过滤一个流
* take 在一个流中截取从开头数的某几个事件
* takeLast 与 take 类型，只不过是从事件末尾开始进行截取
> takeLast 只有当流是有限的情况下或无线流 complete 的情况下有效
* skip 于 take 相反，它的作用是忽略从开头数的某几个事件
* first 等价于 take(1) 取一个流中的第一个事件
* last 等价于 take(n) 取一个流中的最后一个事件，同样具有和takeLast说明中的特性
* takeUntil 直到某一个流开始时，使当前流结束
* merge 将若干个流合并为一个流（按时间顺序）
> merge 描述的业务场景中的事件关系是或的关系，好比一群人赛跑，任何一个人冲过终点，那么比赛的冠军都会产生
* concat 将若干个流组合为一个流（头尾相连）
> 假设 concat(A,B), 那么B流只会在A流结束时开始。
* concatAll 将一个包含若干流的流组合为一个流（头尾相连）
* startWith 将一个流转化为以某个元素为开头的流（产生值的逻辑是同步的）